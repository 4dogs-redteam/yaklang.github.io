---
sidebar_position: 11
---

# 如何编写优秀的 PoC/Exp 👻

大家都很清楚，如果想要验证一个漏洞，我们需要针对这个漏洞进行一系列的探索和研究。经过研究成因和原理之后，我们通常希望得到如下结论作为输出：

1. 漏洞的研究报告
1. 漏洞的 PoC（概念性验证）：可以简单理解为一段可以验证一个目标是否存在这个漏洞的程序/代码/脚本。
1. 漏洞的利用方式：对这个漏洞造成危害的利用和实践。

## 编写优秀的 Web 漏洞 PoC 的关键：

1. 代码本身的健壮性，代码本身最好不能有导致无法运行漏洞检测的 BUG。
1. 针对复杂输入的兼容：
    1. 减轻用户甄别的负担：如果要求的是主机+端口，则能把 URL 等输入自动解析成想要的格式
    1. 如果目标是特定路径的 URL，要可以能解析输入的 IP 以及默认端口等信息，组合出合理的 URL
    1. 如果扫描目标的 URL 不固定，需要页面多个 URL 来作为输入都进行漏洞检测，则可以使用爬虫模块或编写更详细的逻辑来确定扫描目标。
    1. 用户输入的 URL 路径，尽量通过 `file.Join()` 来连接。
1. 可规模化验证：
    1. 为了解决速度问题，可以尝试在漏洞检测之前编写简单的指纹识别，筛除一些不合理的目标
    1. 常量可以作为全局变量，变量不应该作为全局变量

## Yak 中可以用来编写 PoC/Exp 的模块

1. [`http` 模块用于发最基础的 HTTP 请求](/docs/buildinlibs/lib_http)
1. [`fuzz` 用于构造可用于模糊测试的 HTTP 请求](/docs/buildinlibs/lib_fuzz)
1. [`nuclei` 构造适配于 nuclei yaml poc 的 PoC](/docs/buildinlibs/lib_nuclei)

## 在 Yak 中，如何编写 PoC？

### 使用 `http` 构造 PoC

如果一个 PoC 仅仅是特别基础的发送一个请求，根据返回的结果来判断是否存在漏洞，那么这个 PoC 的编写其实非常简单

```go

http.Get("")

```

### 使用 `fuzz` 构造 PoC

我们以这个 PoC 为例，改写为使用 Yak `fuzz` 的 PoC 

[CVE-2021-22873](https://github.com/projectdiscovery/nuclei-templates/blob/master/cves/2021/CVE-2021-22873.yaml)

根据观察，我们发现，这个 PoC 是通过针对一个基础 URL 发送多个请求，请求中构造一个参数，来进行重定向检测的。

```go

```

### 使用 `nuclei` 编写 PoC
