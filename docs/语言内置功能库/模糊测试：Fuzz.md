---
sidebar_position: 3
---

# 【模糊测试】- fuzz

可能是北半球最好用的模糊测试工具包。

很多时候，本扩展包的内容不仅仅可以用于生成模糊测试的 Payload，也可以用于生成批量渲染的 HTTP 请求。

## 为什么会有这个包？fuzz 应该用在哪里？

本身模糊测试并不是一个高深的话题，其实使用场景也非常非常多：

在日常的使用中，我们经常会使用 Burpsuite 的 Intruder 添加自定义字典，批量发送 HTTP 数据包，然后根据测试的结果进行输出点判断。往往这些步骤都是手动进行的，我们的 yak fuzz 模块希望为这种方式提供可编程的实现，帮助大家更容易编写漏洞检测算法，把渗透测试经验，沉淀为可规模化的产品/算法功能。

另一个场景，我们在进行爆破的时候，需要生成字典，例如

```txt
admin1
admin2
admin3
...
admin10
1
2
3
...
10
```

有时候，我们需要扫描某些目标，但是某些情况下，需要调用的文件支持`主机:端口`的形态，我们需要生成目标文件作为别的工具的输入。

等等...

这是一个充满想象力的模块，怎么样使用需要用户极大的发挥自己的想象力。

## 模糊测试字符串

模糊测试字符串的核心函数是

`fn fuzz.Strings(origin: string) []string`

这个函数会把核心的 `{{  }}` 标签转变为需要渲染的内容，例如 `{{int(1-5)}}` 会被渲染为 `[1 2 3 4 5]`

我们的标签是 fuzz 库执行的关键。他其实更像是 `正则` 的逆向，我们规定模糊测试渲染函数和渲染条件，通过执行 `fuzz.Strings` 来获取渲染的结果，以次把一个字符串，变成 N 个字符串。

### QuickStart: 尝试解析一个数字列表

```go
origin := "{{int(1,3,4,80-88)}}"
res := fuzz.Strings(origin)
println("需要模糊渲染的字符串为：", origin)
println("渲染结果为：")
dump(res)

/*
OUTPUT:

需要模糊渲染的字符串为： {{int(1,3,4,80-88)}}
渲染结果为：
([]string) (len=12 cap=12) {
 (string) (len=1) "1",
 (string) (len=1) "3",
 (string) (len=1) "4",
 (string) (len=2) "80",
 (string) (len=2) "81",
 (string) (len=2) "82",
 (string) (len=2) "83",
 (string) (len=2) "84",
 (string) (len=2) "85",
 (string) (len=2) "86",
 (string) (len=2) "87",
 (string) (len=2) "88"
}
*/
```

### fuzz 标签定义以及使用

我们如果想要使用 fuzz 标签，需要明确两个概念，标签的格式是自定义的，目前支持 `{{` 和 `}}` 作为标签的标记，也支持 `__` 和 `__`。

我们以 `{{int()}}` 为例，`int` 代表标签要渲染的具体功能，`()` 括号中的内容是渲染材料，有一些标签需要，有一些标签可以没有，例如 `随机类` 的标签。

在同一个渲染的字符串中，完全相同的标签不会做排列组合，而是被渲染成相同的元素。如果真的需要标签渲染内容完全相同，并且需要分别渲染，可以在标签函数功能后增加一个数字，例如 `{{int1()}}`, `{{int2()}}` 这两个标签同 `{{int()}}` 完全等效，但是可以分别渲染。

#### 标签分级别

一般来说，标签分为两类，优先级不同，编码标签的优先级是最低的。

何为编码标签？

`yak -c 'dump(fuzz.Strings("{{base64enc(aaaaiasdfjklasijldf)}}"))'`

当我们执行上面的代码的时候，我们使用了一个新标签 `base64enc`，这个标签，可以把括号内的内容编码成 `base64`

```go
([]string) (len=1 cap=1) {
 (string) (len=28) "YWFhYWlhc2RmamtsYXNpamxkZg=="
}
```

直接使用 `base64enc` 标签，会编码目标字符串，如果配合其他标签使用，同样也会编码成多个不同的字符串，我们看如下的例子

`yak -c 'dump(fuzz.Strings("{{base64enc(aa-{{int(1-10)}})}}"))'`

执行结果为 

```go
([]string) (len=10 cap=10) {
 (string) (len=8) "YWEtMQ==",
 (string) (len=8) "YWEtMg==",
 (string) (len=8) "YWEtMw==",
 (string) (len=8) "YWEtNA==",
 (string) (len=8) "YWEtNQ==",
 (string) (len=8) "YWEtNg==",
 (string) (len=8) "YWEtNw==",
 (string) (len=8) "YWEtOA==",
 (string) (len=8) "YWEtOQ==",
 (string) (len=8) "YWEtMTA="
}
```

上述结果其实是列表 `[aa-1 aa-2 ... aa-7 aa-8 aa-9 aa-10]` 编码 base64 之后的结果。

### 【基础标签】`{{int}}` 渲染整数/端口

这是我们目前接触过的第一个标签，可以把 `1-10,44,80-800` 这种数字范围的端口转变成分别的数字。

1. 例如 `1-10` 变成 `[1 2 3 4 5 6 ... 9 10]`
2. `1-4,7-9` 变成 `[1 2 3 4 7 8 9]`

#### 用途

最常用的用户其实是渲染一个端口，端口组；

当然，如果我们想要爆破密码的时候，生成密码也可以使用这个标签。

#### 别名

我们以 `{{int(1-10)}}` 为例，如下的写法均等效，**不区分大小写**

1. 增加一个数字后缀 `{{int1(1-10)}}`
2. `{{i(1-10)}}` | `{{i1(1-10)}}` | `{{i2(1-10)}}`
3. `{{port(1-10)}}` | ``{{port2(1-10)}}` `
3. `{{integer(1-10)}}` | ``{{integer2(1-10)}}` `

#### 用法用例，疑难杂症

##### 案例一：最简单的用法

##### 案例二：重复渲染与独立渲染

### 【基础标签】`{{net}} / {{host}}` 渲染扫描目标

### 【基础标签】`{{randstr}} / {{randint}}` 生成随机字符串

### 【基础标签】`{{char}}` 指定生成单个字符