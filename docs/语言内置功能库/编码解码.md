---
sidebar_position: 2
---

# Yak 中的编码解码库

## 可逆编码解码

### 不可见字符打印编码（ASCII）
1. 编码 ASCII，不可见字符编码成 `\xNN`, 带双引号 `fn codec.EncodeASCII(var_1: string): string`
1. 解码操作，`\xNN` 变成具体字符 `fn codec.DecodeASCII(var_1: string): (string, error)`
1. 基本同 `codec.EncodeASCII` 的函数 `fn codec.EncodeToPrintable(var_1: string): string` ，但是只打印可见内容


```go
ret := codec.EncodeASCII("abcdefghijklmn\x99\xFf")
println("编码为：", ret)
res, err := codec.DecodeASCII(ret)
die(err)
println("解码后为: ")
dump([]byte(res))

/*
OUTPUT:

编码为： "abcdefghijklmn\x99\xff"
解码后为:
([]uint8) (len=16 cap=16) {
 00000000  61 62 63 64 65 66 67 68  69 6a 6b 6c 6d 6e 99 ff  |abcdefghijklmn..|
}
*/
```

:::danger
注意，`EncodeASCII / DecodeASCII` 通常用于处理不可见字符，经过编码的字符串保证都是可见字符，并且带上了两边的引号！

相同的，解码的时候，也需要带上引号
:::

### Base64 编码解码

1. `fn codec.DecodeBase64(var_1: string): ([]byte, error)`    **值得注意的是，解码base64的结果为 []byte 即为 bytes**
1. `fn codec.EncodeBase64(var_1: interface {}): string`

```go
ret := codec.EncodeBase64("abcdefghijklmn\x99\xFf")
println("编码为：", ret)
res, err := codec.DecodeBase64(ret)
die(err)
println("解码后为: ")
dump([]byte(res))

/*
OUTPUT:

编码为： YWJjZGVmZ2hpamtsbW6Z/w==
解码后为:
([]uint8) (len=16 cap=18) {
 00000000  61 62 63 64 65 66 67 68  69 6a 6b 6c 6d 6e 99 ff  |abcdefghijklmn..|
}
*/
```

### HTML 实体编码 `#&xxx;`

HTML 实体编码一般用于绕过 XSS

1. `fn codec.DecodeHtml(var_1: string): string`  编码成 `&#123;` 的形式
1. `fn codec.DecodeHtmlHex(var_1: string): string`  编码成 `&#xFF;` 的形式
1. `fn codec.EscapeHtml(var_1: string): string`  只编码特殊字符，`<&>` 等等
1. `fn codec.EncodeHtml(var_1: string): string`  解码

```go
ret := codec.EncodeHtml("abcdefghijklmn\xA0")
println("Html编码为：", ret)
res := codec.DecodeHtml(ret)
println("解码后为: ")
dump([]byte(res))

ret := codec.EncodeHtmlHex("abcdefghijklmn\xA0")
println("Html Hex编码为：", ret)
res := codec.DecodeHtml(ret)
println("解码后为: ")
dump([]byte(res))

ret := codec.EscapeHtml("abcdefghij<>:;{]{]|\\$^&^&#@klmn\xA0")
println("Escape编码为：", ret)
res := codec.DecodeHtml(ret)
println("解码后为: ")
dump([]byte(res))

/*
OUTPUT:

Html编码为： &#97;&#98;&#99;&#100;&#101;&#102;&#103;&#104;&#105;&#106;&#107;&#108;&#109;&#110;&#160;
解码后为:
([]uint8) (len=16 cap=16) {
 00000000  61 62 63 64 65 66 67 68  69 6a 6b 6c 6d 6e c2 a0  |abcdefghijklmn..|
}
Html Hex编码为： &#x61;&#x62;&#x63;&#x64;&#x65;&#x66;&#x67;&#x68;&#x69;&#x6a;&#x6b;&#x6c;&#x6d;&#x6e;&#xa0;
解码后为:
([]uint8) (len=16 cap=16) {
 00000000  61 62 63 64 65 66 67 68  69 6a 6b 6c 6d 6e c2 a0  |abcdefghijklmn..|
}
Escape编码为： abcdefghij&lt;&gt;:;{]{]|\$^&amp;^&amp;#@klmn�
解码后为:
([]uint8) (len=32 cap=32) {
 00000000  61 62 63 64 65 66 67 68  69 6a 3c 3e 3a 3b 7b 5d  |abcdefghij<>:;{]|
 00000010  7b 5d 7c 5c 24 5e 26 5e  26 23 40 6b 6c 6d 6e a0  |{]|\$^&^&#@klmn.|
}
*/
```

### Url 编码


1. `fn codec.EncodeUrl(var_1: string): string`
2. `fn codec.DecodeUrl(var_1: string) (string, error)`

```go
ret := codec.EncodeUrl("abcdefghij<>:;{]{]|\\$^&^&#@klmn\xA0")
println("Url编码为：", ret)
res, err := codec.DecodeUrl(ret)
die(err)
println("解码后为: ")
dump([]byte(res))

/*
OUTPUT:

Url编码为： %61%62%63%64%65%66%67%68%69%6a%3c%3e%3a%3b%7b%5d%7b%5d%7c%5c%24%5e%26%5e%26%23%40%6b%6c%6d%6e%a0
解码后为:
([]uint8) (len=32 cap=32) {
 00000000  61 62 63 64 65 66 67 68  69 6a 3c 3e 3a 3b 7b 5d  |abcdefghij<>:;{]|
 00000010  7b 5d 7c 5c 24 5e 26 5e  26 23 40 6b 6c 6d 6e a0  |{]|\$^&^&#@klmn.|
}
*/
```

#### 只编码需要编码的字符/字符串？

1. `fn codec.EscapePathUrl(var_1: string): string`
1. `fn codec.EscapeQueryUrl(var_1: string): string`
1. `fn codec.UnescapePathUrl(var_1: string): (string, error)`
1. `fn codec.UnescapeQueryUrl(var_1: string): (string, error)`

### 双 URL 编码，常用于 XSS

1. `fn codec.DoubleDecodeUrl(var_1: string): (string, error)`
1. `fn codec.DoubleEncodeUrl(var_1: string): string`

```go

ret := codec.DoubleEncodeUrl("abcdefghij<>:;{]{]|\\$^&^&#@klmn\xA0")
println("Url编码为：", ret)
res, err := codec.DoubleDecodeUrl(ret)
die(err)
println("解码后为: ")
dump([]byte(res))

/*
OUTPUT:

Url编码为： %25%36%31%25%36%32%25%36%33%25%36%34%25%36%35%25%36%36%25%36%37%25%36%38%25%36%39%25%36%61%25%33%63%25%33%65%25%33%61%25%33%62%25%37%62%25%35%64%25%37%62%25%35%64%25%37%63%25%35%63%25%32%34%25%35%65%25%32%36%25%35%65%25%32%36%25%32%33%25%34%30%25%36%62%25%36%63%25%36%64%25%36%65%25%61%30
解码后为:
([]uint8) (len=32 cap=32) {
 00000000  61 62 63 64 65 66 67 68  69 6a 3c 3e 3a 3b 7b 5d  |abcdefghij<>:;{]|
 00000010  7b 5d 7c 5c 24 5e 26 5e  26 23 40 6b 6c 6d 6e a0  |{]|\$^&^&#@klmn.|
}
*/
```


### 十六进制编码

十六进制编码，转成十六进制字符串

1. `fn codec.DecodeToHex(var_1: string): ([]uint8, error)`
1. `fn codec.EncodeToHex(var_1: interface {}): string`

```go
ret := codec.EncodeToHex("abcdefghij<>:;{]{]|\\$^&^&#@klmn\xA0")
println("Url编码为：", ret)
res, err := codec.DecodeToHex(ret)
die(err)
println("解码后为: ")
dump([]byte(res))

/*
OUTPUT:

Url编码为： 6162636465666768696a3c3e3a3b7b5d7b5d7c5c245e265e2623406b6c6d6ea0
解码后为:
([]uint8) (len=32 cap=64) {
 00000000  61 62 63 64 65 66 67 68  69 6a 3c 3e 3a 3b 7b 5d  |abcdefghij<>:;{]|
 00000010  7b 5d 7c 5c 24 5e 26 5e  26 23 40 6b 6c 6d 6e a0  |{]|\$^&^&#@klmn.|
}
*/
```

:::info
要注意，如果这个十六进制字符串需要在 mysql 中展示，记得加 `0x` 前缀喔
:::

### Hash 计算与编码

1. `fn codec.Md5(var_1: interface {}): string`
1. `fn codec.Sha1(var_1: interface {}): string`
1. `fn codec.Sha224(var_1: interface {}): string`
1. `fn codec.Sha256(var_1: interface {}): string`
1. `fn codec.Sha384(var_1: interface {}): string`
1. `fn codec.Sha512(var_1: interface {}): string`

